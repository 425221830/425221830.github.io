<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Cookie和Session]]></title>
      <url>%2F2017%2F04%2F15%2FCookie%26Session%2F</url>
      <content type="text"><![CDATA[本篇文章简单记录了关于Web会话管理技术的学习笔记。 目前常用的会话管理技术是Cookie与Session Cookie通过在客户端记录信息确定用户身份 Session通过在服务器端记录信息确定用户身份。 会话管理 会话管理： 管理浏览器和服务器之间的会话过程中产生的会话数据 Cookie Cookie机制的引入 在Web应用程序是使用HTTP协议传输数据的。HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。 Cookie就是记录会话数据这样的一种机制。它可以弥补HTTP协议无状态的不足。 Cookie原理 Cookie是客户端技术，服务器把每个用户的数据以cookie的形式写给用户各自的浏览器。当用户使用浏览器再去访问服务器中的web资源时，就会带着各自的数据去，这样，web资源处理的就是用户各自的数据了。 Cookie机制的流程 服务器创建cookie对象，把会话数据存储到cookie对象中。 new Cookie(“name”,“value”); 服务器发送cookie信息到浏览器 response.addCookie(cookie); 举例： set-cookie: name=xiseven (隐藏发送了一个set-cookie名称的响应头) 浏览器得到服务器发送的cookie，然后保存在浏览器端。 浏览器在下次访问服务器时，会带着cookie信息 举例： cookie: name=xiseven (隐藏带着一个叫cookie名称的请求头) 服务器接收到浏览器带来的cookie信息 request.getCookies(); Cookie核心API 12345678910111213141516171）构造Cookie对象 Cookie(java.lang.String name, java.lang.String value)2）设置cookie //设置cookie的有效访问路径 void setPath(java.lang.String uri) //设置cookie的有效时间 void setMaxAge(int expiry) //设置cookie的值 void setValue(java.lang.String newValue) //设置cookie的有效域 void setDomain(String pattern)3）发送cookie到浏览器端保存 //发送cookie void response.addCookie(Cookie cookie)4）服务器接收cookie //接收cookie Cookie[] request.getCookies() Cookie细节 一个Cookie只能标识一种信息，它至少含有一个标识该信息的名称（NAME）和设置值（VALUE）。 void setPath(java.lang.String uri) ：设置cookie的有效访问路径。有效路径指的是cookie的有效路径保存在哪里，那么浏览器在有效路径下访问服务器时就会带着cookie信息，否则不带cookie信息。 void setMaxAge(int expiry) ： 设置cookie的有效时间。 正整数：表示cookie数据保存浏览器的缓存目录（硬盘中），数值表示保存的时间。 负整数：表示cookie数据保存浏览器的内存中。浏览器关闭cookie就丢失了！！ 零：表示删除同名的cookie数据 注意，删除cookie时，path必须一致，否则不会删除 一个WEB站点可以给一个WEB浏览器发送多个Cookie，一个WEB浏览器也可以存储多个WEB站点提供的Cookie，但是浏览器一般只允许存放300个Cookie，每个站点最多存放20个Cookie，每个Cookie的大小限制为4KB。 Cookie中存储中文 12345//必须使用URLEncoder类里面的encode(String s, String enc)方法进行中文转码Cookie cookie = new Cookie("userName", URLEncoder.encode("用户名", "UTF-8"));response.addCookie(cookie);//获取cookie中的中文数据，使用URLDecoder类里面的decode(String s, String enc)进行解码URLDecoder.decode(cookies[i].getValue(), "UTF-8"); Session Session机制的引入 Cookie的局限： Cookie只能存字符串类型。不能保存对象 不能直接存储中文字符。 1个Cookie的容量不超过4KB。 因为Cookie的种种局限所以引入Session机制，可以很好的解决以上的问题 Session原理 Session是服务器技术，服务器可以为每个用户浏览器创建一个会话对象（session对象），注意：一个浏览器独占一个session对象(默认情况下)。因此，在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的session中，当用户使用浏览器访问其它程序时，其它程序可以从用户的session中取出该用户的数据，为用户服务。 Session机制的流程： 以下是服务器内部的行为 第一次访问创建session对象，给session对象分配一个唯一的ID，叫JSESSIONID new HttpSession(); 把JSESSIONID作为Cookie的值发送给浏览器保存 Cookie cookie = new Cookie(“JSESSIONID”, sessionID); response.addCookie(cookie); 第二次访问的时候，浏览器带着JSESSIONID的cookie访问服务器 服务器得到JSESSIONID，在服务器的内存中搜索是否存放对应编号的session对象。 12345678服务器搜索session对象的伪代码if(找到)&#123; return map.get(sessionID);&#125;存储session对象的Map结构Map&lt;String,HttpSession&gt;&lt;&quot;001&quot;, s1&gt;&lt;&quot;001&quot;, s2&gt; 如果找到对应编号的session对象，直接返回该对象 如果找不到对应编号的session对象，创建新的session对象，继续走1的流程 Session核心API 方法 描述 void setAttribute(String attribute, Object value) 设置Session属性。value参数可以为任何Java Object。通常为Java Bean。value信息不宜过大 String getAttribute(String attribute) 返回Session属性 Enumeration getAttributeNames() 返回Session中存在的属性名 void removeAttribute(String attribute) 移除Session属性 String getId() 返回Session的ID。该ID由服务器自动创建，不会重复 long getCreationTime() 返回Session的创建日期。返回类型为long，常被转化为Date类型，例如：Date createTime = new Date(session.getCreationTime()) long getLastAccessedTime() 返回Session的最后活跃时间。返回类型为long int getMaxInactiveInterval() 返回Session的超时时间。单位为秒。超过该时间没有访问，服务器认为该Session失效 void setMaxInactiveInterval(int second) 设置Session的超时时间。单位为秒 boolean isNew() 返回该Session是否是新创建的 void invalidate() 使该Session失效 Session细节 两个getSession方法： getSession(true) / getSession() : 创建或得到session对象。没有匹配的session编号，自动创建新的session对象。 getSession(false) : 得到session对象。没有匹配的session编号，返回null Session对象销毁时间： 手动销毁Session对象invalidate() 默认情况30分钟不访问服务器自动回收 手动修改Session回事时间setMaxInactiveInterval() 全局修改Session有效时间（修改web.xml） 1234&lt;!-- 修改session全局有效时间:分钟 --&gt;&lt;session-config&gt; &lt;session-timeout&gt;1&lt;/session-timeout&gt;&lt;/session-config&gt; 浏览器禁用Cookie后的Session处理 解决方案：URL重写，使用一下方法可将SessionId信息写入URL，不必依赖于Cookie response. encodeRedirectURL(java.lang.String url) 用于对sendRedirect方法后的url地址进行重写。 response. encodeURL(java.lang.String url) 用于对表单action和超链接的url地址进行重写]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于转发和重定向]]></title>
      <url>%2F2017%2F04%2F09%2F%E8%BD%AC%E5%8F%91%26%E9%87%8D%E5%AE%9A%E5%90%91%2F</url>
      <content type="text"><![CDATA[由于课程缘故，最近恶补Java后台知识，不过也好，因为从一些信息渠道了解说移动端需求不如之前了，所以多学点后台知识提高自己，免得以后没饭吃，哈哈哈！ 这篇文章就来记录一下HTTP 转发和重定向 实现形式 首先来看看两者的实现形式（以下示例均交由jsp处理，当然也可给servlet处理） （吐个槽：自己学才知道jsp和servlet本质是一样的，之前上课老师讲了一学期硬是没听明白，可能是自己没专心学吧） 转发： 1request.getRequestDispatcher("new.jsp").forward(request, response); //转发到new.jsp 重定向： 1response.sendRedirect("new.jsp"); //重定向到new.jsp 很明显我们可以看出转发是又request完成的，而且在转发的实现中调用forward方法传入了request和response两个参数，而重定向是由response完成的。在我们接下来进行的对比中就能发现，为什么会有这样的区别。 过程对比 转发： 在转发的过程中我们是利用request实现，并且将request和response传给下一个jsp或servlet，很容易理解这就是一个服务器内部的行为，由服务器将请求交给下一个处理的jsp或servlet。 重定向： 在重定向中服务器实际上是利用response给客户端返回一个302状态码和一个新的location响应头，此时客户端收到302状态码会重新发送一个请求，而此时的请求地址已经是服务器重定向返回的新地址。 重定向实际的实现： 12response.setStatus(302); //发送302状态码response.setHeader("location", "new.jsp"); //发送location的响应头 转发的完整过程： 客户浏览器发送http请求——》web服务器接受此请求——》调用内部的一个方法在容器内部完成请求处理和转发动作——》将目标资源发送给客户；在这里，转发的路径必须是同一个web容器下的url，其不能转向到其他的web路径上去，中间传递的是自己的容器内的request。在客户浏览器路径栏显示的仍然是其第一次访问的路径，也就是说客户是感觉不到服务器做了转发的。转发行为是浏览器只做了一次访问请求。 重定向的完整过程： 客户浏览器发送http请求——》web服务器接受后发送302状态码响应及对应新的location给客户浏览器——》客户浏览器发现是302响应，则自动再发送一个新的http请求，请求url是新的location地址——》服务器根据此请求寻找资源并发送给客户。在这里location可以重定向到任意URL，既然是浏览器重新发出了请求，则就没有什么request传递的概念了。在客户浏览器路径栏显示的是其重定向的路径，客户可以观察到地址的变化的。重定向行为是浏览器做了至少两次的访问请求的。 总结 转发 1）地址栏不会改变 2）转发只能转发到当前web应用内的资源，只需要给出转发的资源路径即可 3）可以在转发过程中，可以把数据保存到request域对象中 重定向 1）地址栏会改变，变成重定向到地址。 2）重定向可以跳转到当前web应用，或其他web应用，甚至是外部域名网站，所以需要给出全路径，即路径要包含项目名 3）不能再重定向的过程，把数据保存到request中。 开发中，如果需要地址栏的地址发生改变，就选择重定向； 如果需要在Servlet之间通过request域进行数据通信，就选择请求转发。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于http协议的学习记录]]></title>
      <url>%2F2017%2F03%2F27%2FStudyHttpRecord%2F</url>
      <content type="text"><![CDATA[http是什么 词条的解释是：超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。 我的理解就是：客户端与服务端之间的数据传输的格式规范。 什么是http（http的内容） 按照我的学习理解，http分两部分 http请求（客户端 --&gt; 服务端） http响应（服务端 --&gt; 客户端） http请求 http请求的格式 1234&lt;request-line&gt; -请求行 &lt;request-headers&gt; -请求头（包含多个内容）&lt;empty-line&gt; -空行[&lt;message-body&gt;] -实体内容 http请求示例 GET /hello HTTP/1.1 ----请求行（请求方式 uri http协议） Host: localhost:8080 ----主机地址 User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:35.0) Gecko/20100101 Firefox/35.0 ----客户端的身份信息 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8 ----接收的格式类型 Accept-Language: zh-cn,en-us;q=0.8,zh;q=0.5,en;q=0.3 ----接收的语言 Accept-Encoding: gzip, deflate ----接收压缩格式 Connection: keep-alive ----连接状态，保持连接 ----一个空行 name=eric&amp;password=123456 ----（可选）实体内容 http请求详解 请求行 请求方法（GET 、POST、HEAD、TRACE、PUT、CONNECT 、DELETE），以下两种最为常用 GET方法： 地址栏（URI）会跟上参数数据。以？开头，多个参数之间以&amp;分割。 GET提交参数数据有限制，不超过1KB。 GET方式不适合提交敏感密码。（参数会显示到地址栏） 注意： 浏览器直接访问的请求，默认提交方式是GET方式 POST方法： 参数不会跟着URI后面。参数而是跟在请求的实体内容中。 POST提交的参数数据没有限制。 请求资源 URL： 统一资源定位符。只能定位互联网资源。是URI的子集。 URI： 统一资源标记符。用于标记任何资源。可以是本地文件系统，局域网的资源，也可以是互联网。 HTTP版本：目前主要分1.0和1.1 HTTP/1.0：非持久连接，建立连接后只能发送一次请求，一次请求之后连接关闭。 请求头中的Connection：close HTTP/1.1：默认使用持久连接，建立连接后可以在一次连接中发送多次请求。（基本都使用1.1）。 请求头中的Connection：keep-alive 请求头： 多个key-value对象 Accept: text/html,image/* – 浏览器接受的数据类型 Accept-Charset: ISO-8859-1 – 浏览器接受的编码格式 Accept-Encoding: gzip,compress –浏览器接受的数据压缩格式 Accept-Language: en-us,zh- –浏览器接受的语言 Host: www.it315.org:80 –（必须的）当前请求访问的目标地址（主机:端口） If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT –浏览器最后的缓存时间 Referer: http://www.it315.org/index.jsp – 当前请求来自于哪里 User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0) –浏览器类型 Cookie:name=eric – 浏览器保存的cookie信息 Connection: close/Keep-Alive – 浏览器跟服务器连接状态。close: 连接关闭 keep-alive：保存连接。 Date: Tue, 11 Jul 2000 18:23:51 GMT – 请求发出的时间 空行： 通知服务器以下不再有请求头 实体内容 只有POST提交的参数会放到实体内容中 http响应 http响应的格式 1234&lt;status-line&gt; --状态行&lt;response-headers&gt; --响应头&lt;empty-line&gt; --空行[&lt;message-body&gt;] --实体内容 http响应示例 HTTP/1.1 200 OK Date: Sat, 31 Dec 2005 23:59:59 GMT Content-Type: text/html;charset=ISO-8859-1 Content-Length: 122 –空行 ＜html＞ … ＜/html＞ http响应详解 状态行 协议版本： 可参上请求行/HTTP版本 状态码： 介绍： 状态代码为3位数字，200-299的状态码表示成功，300-399的状态码指资源重定向，400-499的状态码指客户端请求出错，500-599的状态码指服务端出错（HTTP/1.1向协议中引入了信息性状态码，范围为100-199） 常见例子： 状态码 说明 200 响应成功 302 跳转，跳转地址通过响应头中的Location属性指定 400 客户端请求有语法错误，不能被服务器识别 403 服务器接收到请求，但是拒绝提供服务（认证失败） 404 请求资源不存在 500 服务器内部错误 状态码描述 响应头 Location: http://www.it315.org/index.jsp --表示重定向的地址，该头和302的状态码一起使用。 Server:apache tomcat --表示服务器的类型 Content-Encoding: gzip – 表示服务器发送给浏览器的数据压缩类型 Content-Length: 80 --表示服务器发送给浏览器的数据长度 Content-Language: zh-cn --表示服务器支持的语言 Content-Type: text/html; charset=GB2312 --表示服务器发送给浏览器的数据类型及内容编码 Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT --表示服务器资源的最后修改时间 Refresh: 1;url=http://www.it315.org --表示定时刷新 Content-Disposition: attachment; filename=aaa.zip --表示告诉浏览器以下载方式打开资源（下载文件时用到） Transfer-Encoding: chunked Set-Cookie:SS=Q0=5Lb_nQ; path=/search --表示服务器发送给浏览器的cookie信息（会话管理用到） Expires: -1 --表示通知浏览器不进行缓存 Cache-Control: no-cache Pragma: no-cache Connection: close/Keep-Alive --表示服务器和浏览器的连接状态。close：关闭连接 keep-alive:保存连接 空行： 通知服务器以下不再有响应头 实体内容： 即服务器返回的内容]]></content>
    </entry>

    
  
  
</search>
